{"name": "test_openpart[全流程测试]", "status": "broken", "statusDetails": {"message": "TypeError: not all arguments converted during string formatting", "trace": "self = <pywinauto.application.WindowSpecification object at 0x000002270DEC82B0>, criteria = [{'backend': 'win32', 'best_match': '打开文件', 'top_level_only': True}, {'best_match': 'Toolbar4'}], timeout = 5.0, retry_interval = 0.09\n\n    def __resolve_control(self, criteria, timeout=None, retry_interval=None):\n        \"\"\"\n        Find a control using criteria\n    \n        * **criteria** - a list that contains 1 or 2 dictionaries\n    \n             1st element is search criteria for the dialog\n    \n             2nd element is search criteria for a control of the dialog\n    \n        * **timeout** -  maximum length of time to try to find the controls (default 5)\n        * **retry_interval** - how long to wait between each retry (default .2)\n        \"\"\"\n        if timeout is None:\n            timeout = Timings.window_find_timeout\n        if retry_interval is None:\n            retry_interval = Timings.window_find_retry\n    \n        try:\n            ctrl = wait_until_passes(\n                timeout,\n                retry_interval,\n                self.__get_ctrl,\n                (findwindows.ElementNotFoundError,\n                 findbestmatch.MatchError,\n                 controls.InvalidWindowHandle,\n                 controls.InvalidElement),\n>               criteria)\n\nd:\\program files(x86)\\python3.7\\lib\\site-packages\\pywinauto\\application.py:258: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntimeout = 5.0, retry_interval = 0.09, func = <bound method WindowSpecification.__get_ctrl of <pywinauto.application.WindowSpecification object at 0x000002270DEC82B0>>\nexceptions = (<class 'pywinauto.findwindows.ElementNotFoundError'>, <class 'pywinauto.findbestmatch.MatchError'>, <class 'pywinauto.controls.hwndwrapper.InvalidWindowHandle'>, <class 'pywinauto.base_wrapper.InvalidElement'>)\nargs = ([{'backend': 'win32', 'best_match': '打开文件', 'top_level_only': True}, {'best_match': 'Toolbar4'}],), kwargs = {}, start = 22.3160513, time_left = -0.04732759999999914, err = TimeoutError()\n\n    def wait_until_passes(timeout,\n                          retry_interval,\n                          func,\n                          exceptions=(Exception),\n                          *args, **kwargs):\n        \"\"\"\n        Wait until ``func(*args, **kwargs)`` does not raise one of the exceptions\n    \n        * **timeout**  how long the function will try the function\n        * **retry_interval**  how long to wait between retries\n        * **func** the function that will be executed\n        * **exceptions**  list of exceptions to test against (default: Exception)\n        * **args** optional arguments to be passed to func when called\n        * **kwargs** optional keyword arguments to be passed to func when called\n    \n        Returns the return value of the function\n        If the operation times out then the original exception raised is in\n        the 'original_exception' attribute of the raised exception.\n    \n        e.g. ::\n    \n            try:\n                # wait a maximum of 10.5 seconds for the\n                # window to be found in increments of .5 of a second.\n                # P.int a message and re-raise the original exception if never found.\n                wait_until_passes(10.5, .5, self.Exists, (ElementNotFoundError))\n            except TimeoutError as e:\n                print(\"timed out\")\n                raise e.\n        \"\"\"\n        start = timestamp()\n    \n        # keep trying until the timeout is passed\n        while True:\n            try:\n                # Call the function with any arguments\n                func_val = func(*args, **kwargs)\n    \n                # if no exception is raised then we are finished\n                break\n    \n            # An exception was raised - so wait and try again\n            except exceptions as e:\n    \n                # find out how much of the time is left\n                time_left = timeout - (timestamp() - start)\n    \n                # if we have to wait some more\n                if time_left > 0:\n                    # wait either the retry_interval or else the amount of\n                    # time until the timeout expires (whichever is less)\n                    time.sleep(min(retry_interval, time_left))\n    \n                else:\n                    # Raise a TimeoutError - and put the original exception\n                    # inside it\n                    err = TimeoutError()\n                    err.original_exception = e\n>                   raise err\nE                   pywinauto.timings.TimeoutError\n\nd:\\program files(x86)\\python3.7\\lib\\site-packages\\pywinauto\\timings.py:458: TimeoutError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <flow_page.main_page.MainPage object at 0x000002270D6B7D68>, path = 'E:\\\\model\\\\model', model = '\"孔洞花瓶.stl\" \"谢牙龈.stl\"'\n\n    def openfile(self, path, model):\n        \"\"\"\n        :param path: 模型路径\n        :param model: 模型名称，多模型例 '\"格子收纳盒.stl\"\"heart.stl\"'\n        :return: 按钮文本\n        \"\"\"\n        try:\n            openfile_text = self.find(title=\"本地打开\", auto_id=\"FormMain.rightwidget.stackedWidget.FormLoad.pbLocal\",\n                                      control_type=\"Button\").texts()[0]\n            self.click(title=\"本地打开\", auto_id=\"FormMain.rightwidget.stackedWidget.FormLoad.pbLocal\",\n                       control_type=\"Button\")\n            LogRoot.info(\"点击本地打开按钮\")\n>           self.win_desktop(win_title=\"打开文件\", path_bar=\"Toolbar4\", path=path, filename=model)\n\nflow_page\\main_page.py:187: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <flow_page.main_page.MainPage object at 0x000002270D6B7D68>, win_title = '打开文件', path = 'E:\\\\model\\\\model', filename = '\"孔洞花瓶.stl\" \"谢牙龈.stl\"', path_bar = 'Toolbar4'\n\n    def win_desktop(self, win_title,path, filename, path_bar=None):\n        \"\"\"\n        :param win_title: 弹框title\n        :param path_bar: path输入框index\n        :param path_autoid: path输入框autoid\n        :param path: 文件路径\n        :param filename: 文件名\n        :return:\n        \"\"\"\n        win = pywinauto.Desktop()\n        openconf = win[win_title]\n>       openconf[path_bar].click()\n\nbase\\main.py:55: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pywinauto.application.WindowSpecification object at 0x000002270DEC82B0>, attr_name = 'click'\n\n    def __getattribute__(self, attr_name):\n        \"\"\"\n        Attribute access for this class\n    \n        If we already have criteria for both dialog and control then\n        resolve the control and return the requested attribute.\n    \n        If we have only criteria for the dialog but the attribute\n        requested is an attribute of DialogWrapper then resolve the\n        dialog and return the requested attribute.\n    \n        Otherwise delegate functionality to :func:`__getitem__` - which\n        sets the appropriate criteria for the control.\n        \"\"\"\n        allow_magic_lookup = object.__getattribute__(self, \"allow_magic_lookup\")  # Beware of recursions here!\n        if not allow_magic_lookup:\n            try:\n                return object.__getattribute__(self, attr_name)\n            except AttributeError:\n                wrapper_object = self.wrapper_object()\n                try:\n                    return getattr(wrapper_object, attr_name)\n                except AttributeError:\n                    message = (\n                        'Attribute \"%s\" exists neither on %s object nor on'\n                        'targeted %s element wrapper (typo? or set allow_magic_lookup to True?)' %\n                        (attr_name, self.__class__, wrapper_object.__class__))\n                    raise AttributeError(message)\n    \n        if attr_name in ['__dict__', '__members__', '__methods__', '__class__', '__name__']:\n            return object.__getattribute__(self, attr_name)\n    \n        if attr_name in dir(self.__class__):\n            return object.__getattribute__(self, attr_name)\n    \n        if attr_name in self.__dict__:\n            return self.__dict__[attr_name]\n    \n        # if we already have 2 levels of criteria (dlg, control)\n        # this third must be an attribute so resolve and get the\n        # attribute and return it\n        if len(self.criteria) >= 2:  # FIXME - this is surprising\n    \n>           ctrls = self.__resolve_control(self.criteria)\n\nd:\\program files(x86)\\python3.7\\lib\\site-packages\\pywinauto\\application.py:379: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pywinauto.application.WindowSpecification object at 0x000002270DEC82B0>, criteria = [{'backend': 'win32', 'best_match': '打开文件', 'top_level_only': True}, {'best_match': 'Toolbar4'}], timeout = 5.0, retry_interval = 0.09\n\n    def __resolve_control(self, criteria, timeout=None, retry_interval=None):\n        \"\"\"\n        Find a control using criteria\n    \n        * **criteria** - a list that contains 1 or 2 dictionaries\n    \n             1st element is search criteria for the dialog\n    \n             2nd element is search criteria for a control of the dialog\n    \n        * **timeout** -  maximum length of time to try to find the controls (default 5)\n        * **retry_interval** - how long to wait between each retry (default .2)\n        \"\"\"\n        if timeout is None:\n            timeout = Timings.window_find_timeout\n        if retry_interval is None:\n            retry_interval = Timings.window_find_retry\n    \n        try:\n            ctrl = wait_until_passes(\n                timeout,\n                retry_interval,\n                self.__get_ctrl,\n                (findwindows.ElementNotFoundError,\n                 findbestmatch.MatchError,\n                 controls.InvalidWindowHandle,\n                 controls.InvalidElement),\n                criteria)\n    \n        except TimeoutError as e:\n>           raise e.original_exception\n\nd:\\program files(x86)\\python3.7\\lib\\site-packages\\pywinauto\\application.py:261: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntimeout = 5.0, retry_interval = 0.09, func = <bound method WindowSpecification.__get_ctrl of <pywinauto.application.WindowSpecification object at 0x000002270DEC82B0>>\nexceptions = (<class 'pywinauto.findwindows.ElementNotFoundError'>, <class 'pywinauto.findbestmatch.MatchError'>, <class 'pywinauto.controls.hwndwrapper.InvalidWindowHandle'>, <class 'pywinauto.base_wrapper.InvalidElement'>)\nargs = ([{'backend': 'win32', 'best_match': '打开文件', 'top_level_only': True}, {'best_match': 'Toolbar4'}],), kwargs = {}, start = 22.3160513, time_left = -0.04732759999999914, err = TimeoutError()\n\n    def wait_until_passes(timeout,\n                          retry_interval,\n                          func,\n                          exceptions=(Exception),\n                          *args, **kwargs):\n        \"\"\"\n        Wait until ``func(*args, **kwargs)`` does not raise one of the exceptions\n    \n        * **timeout**  how long the function will try the function\n        * **retry_interval**  how long to wait between retries\n        * **func** the function that will be executed\n        * **exceptions**  list of exceptions to test against (default: Exception)\n        * **args** optional arguments to be passed to func when called\n        * **kwargs** optional keyword arguments to be passed to func when called\n    \n        Returns the return value of the function\n        If the operation times out then the original exception raised is in\n        the 'original_exception' attribute of the raised exception.\n    \n        e.g. ::\n    \n            try:\n                # wait a maximum of 10.5 seconds for the\n                # window to be found in increments of .5 of a second.\n                # P.int a message and re-raise the original exception if never found.\n                wait_until_passes(10.5, .5, self.Exists, (ElementNotFoundError))\n            except TimeoutError as e:\n                print(\"timed out\")\n                raise e.\n        \"\"\"\n        start = timestamp()\n    \n        # keep trying until the timeout is passed\n        while True:\n            try:\n                # Call the function with any arguments\n>               func_val = func(*args, **kwargs)\n\nd:\\program files(x86)\\python3.7\\lib\\site-packages\\pywinauto\\timings.py:436: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pywinauto.application.WindowSpecification object at 0x000002270DEC82B0>, criteria_ = [{'backend': 'win32', 'best_match': '打开文件', 'top_level_only': True}, {'best_match': 'Toolbar4'}]\n\n    def __get_ctrl(self, criteria_):\n        \"\"\"Get a control based on the various criteria\"\"\"\n        # make a copy of the criteria\n        criteria = [crit.copy() for crit in criteria_]\n        # find the dialog\n        if 'backend' not in criteria[0]:\n            criteria[0]['backend'] = self.backend.name\n        if self.app is not None:\n            # find_elements(...) accepts only \"process\" argument\n            criteria[0]['process'] = self.app.process\n            del criteria[0]['app']\n>       dialog = self.backend.generic_wrapper_class(findwindows.find_element(**criteria[0]))\n\nd:\\program files(x86)\\python3.7\\lib\\site-packages\\pywinauto\\application.py:203: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nkwargs = {'backend': 'win32', 'best_match': '打开文件', 'top_level_only': True}\n\n    def find_element(**kwargs):\n        \"\"\"\n        Call find_elements and ensure that only one element is returned\n    \n        Calls find_elements with exactly the same arguments as it is called with\n        so please see :py:func:`find_elements` for the full parameters description.\n        \"\"\"\n>       elements = find_elements(**kwargs)\n\nd:\\program files(x86)\\python3.7\\lib\\site-packages\\pywinauto\\findwindows.py:84: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nclass_name = None, class_name_re = None, parent = None, process = None, title = None, title_re = None, top_level_only = True, visible_only = True, enabled_only = False, best_match = '打开文件', handle = None, ctrl_index = None\nfound_index = None, predicate_func = None, active_only = False, control_id = None, control_type = None, auto_id = None, framework_id = None, backend = 'win32', depth = None\n\n    def find_elements(class_name=None,\n                      class_name_re=None,\n                      parent=None,\n                      process=None,\n                      title=None,\n                      title_re=None,\n                      top_level_only=True,\n                      visible_only=True,\n                      enabled_only=False,\n                      best_match=None,\n                      handle=None,\n                      ctrl_index=None,\n                      found_index=None,\n                      predicate_func=None,\n                      active_only=False,\n                      control_id=None,\n                      control_type=None,\n                      auto_id=None,\n                      framework_id=None,\n                      backend=None,\n                      depth=None\n                      ):\n        \"\"\"\n        Find elements based on criteria passed in\n    \n        WARNING! Direct usage of this function is not recommended! It's a very low level API.\n        Better use Application and WindowSpecification objects described in the\n        Getting Started Guide.\n    \n        Possible values are:\n    \n        * **class_name**     Elements with this window class\n        * **class_name_re**  Elements whose class matches this regular expression\n        * **parent**         Elements that are children of this\n        * **process**        Elements running in this process\n        * **title**          Elements with this text\n        * **title_re**       Elements whose text matches this regular expression\n        * **top_level_only** Top level elements only (default=**True**)\n        * **visible_only**   Visible elements only (default=**True**)\n        * **enabled_only**   Enabled elements only (default=False)\n        * **best_match**     Elements with a title similar to this\n        * **handle**         The handle of the element to return\n        * **ctrl_index**     The index of the child element to return\n        * **found_index**    The index of the filtered out child element to return\n        * **predicate_func** A user provided hook for a custom element validation\n        * **active_only**    Active elements only (default=False)\n        * **control_id**     Elements with this control id\n        * **control_type**   Elements with this control type (string; for UIAutomation elements)\n        * **auto_id**        Elements with this automation id (for UIAutomation elements)\n        * **framework_id**   Elements with this framework id (for UIAutomation elements)\n        * **backend**        Back-end name to use while searching (default=None means current active backend)\n        \"\"\"\n        if backend is None:\n            backend = registry.active_backend.name\n        backend_obj = registry.backends[backend]\n    \n        # allow a handle to be passed in\n        # if it is present - just return it\n        if handle is not None:\n            return [backend_obj.element_info_class(handle), ]\n    \n        if isinstance(parent, backend_obj.generic_wrapper_class):\n            parent = parent.element_info\n        elif isinstance(parent, six.integer_types):\n            # check if parent is a handle of element (in case of searching native controls)\n            parent = backend_obj.element_info_class(parent)\n    \n        if top_level_only:\n            # find the top level elements\n            element = backend_obj.element_info_class()\n            # vryabov: we don't use title=title below, because it fixes issue 779:\n            # https://github.com/pywinauto/pywinauto/issues/779\n            elements = element.children(process=process,\n                                        class_name=class_name,\n                                        control_type=control_type,\n                                        cache_enable=True)\n    \n            # if we have been given a parent\n            if parent:\n                elements = [elem for elem in elements if elem.parent == parent]\n    \n        # looking for child elements\n        else:\n            # if not given a parent look for all children of the desktop\n            if not parent:\n                parent = backend_obj.element_info_class()\n    \n            # look for ALL children of that parent\n            # vryabov: we don't use title=title below, because it fixes issue 779:\n            # https://github.com/pywinauto/pywinauto/issues/779\n            elements = parent.descendants(class_name=class_name,\n                                          control_type=control_type,\n                                          cache_enable=True,\n                                          depth=depth)\n    \n            # if the ctrl_index has been specified then just return\n            # that control\n            if ctrl_index is not None:\n                return [elements[ctrl_index], ]\n    \n        # early stop\n        if not elements:\n            if found_index is not None:\n                if found_index > 0:\n                    raise ElementNotFoundError(\"found_index is specified as {0}, but no windows found\".format(\n                        found_index))\n            return elements\n    \n        if framework_id is not None and elements:\n            elements = [elem for elem in elements if elem.framework_id == framework_id]\n    \n        if control_id is not None and elements:\n            elements = [elem for elem in elements if elem.control_id == control_id]\n    \n        if active_only:\n            # TODO: re-write to use ElementInfo interface\n            gui_info = win32structures.GUITHREADINFO()\n            gui_info.cbSize = ctypes.sizeof(gui_info)\n    \n            # get all the active elements (not just the specified process)\n            ret = win32functions.GetGUIThreadInfo(0, ctypes.byref(gui_info))\n    \n            if not ret:\n                raise ctypes.WinError()\n    \n            found_active = False\n            for elem in elements:\n                if elem.handle == gui_info.hwndActive:\n                    found_active = True\n                    elements = [elem, ]\n                    break\n            if not found_active:\n                elements = []\n    \n        if class_name is not None:\n            elements = [elem for elem in elements if elem.class_name == class_name]\n    \n        if class_name_re is not None:\n            class_name_regex = re.compile(class_name_re)\n            elements = [elem for elem in elements if class_name_regex.match(elem.class_name)]\n    \n        if process is not None:\n            elements = [elem for elem in elements if elem.process_id == process]\n    \n        if auto_id is not None and elements:\n            elements = [elem for elem in elements if elem.automation_id == auto_id]\n    \n        if title is not None:\n            # TODO: some magic is happenning here\n            if elements:\n                elements[0].rich_text\n            elements = [elem for elem in elements if elem.rich_text == title]\n        elif title_re is not None:\n            title_regex = re.compile(title_re)\n    \n            def _title_match(w):\n                \"\"\"Match a window title to the regexp\"\"\"\n                t = w.rich_text\n                if t is not None:\n                    return title_regex.match(t)\n                return False\n            elements = [elem for elem in elements if _title_match(elem)]\n    \n        if visible_only:\n            elements = [elem for elem in elements if elem.visible]\n    \n        if enabled_only:\n            elements = [elem for elem in elements if elem.enabled]\n    \n        if best_match is not None:\n            # Build a list of wrapped controls.\n            # Speed up the loop by setting up local pointers\n            wrapped_elems = []\n            add_to_wrp_elems = wrapped_elems.append\n            wrp_cls = backend_obj.generic_wrapper_class\n            for elem in elements:\n                try:\n                    add_to_wrp_elems(wrp_cls(elem))\n                except (controls.InvalidWindowHandle,\n                        controls.InvalidElement):\n                    # skip invalid handles - they have dissapeared\n                    # since the list of elements was retrieved\n                    continue\n>           elements = findbestmatch.find_best_control_matches(best_match, wrapped_elems)\n\nd:\\program files(x86)\\python3.7\\lib\\site-packages\\pywinauto\\findwindows.py:305: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsearch_text = '打开文件'\ncontrols = [<hwndwrapper.DialogWrapper - '', Shell_TrayWnd, 65776>, <hwndwrapper.DialogWrapper - '', Shell_SecondaryTrayWnd, 1336...r.DialogWrapper - '任务管理器', TaskManagerWindow, 2624202>, <hwndwrapper.DialogWrapper - '', Alternate Owner, 135270>, ...]\n\n    def find_best_control_matches(search_text, controls):\n        \"\"\"Returns the control that is the the best match to search_text\n    \n        This is slightly differnt from find_best_match in that it builds\n        up the list of text items to search through using information\n        from each control. So for example for there is an OK, Button\n        then the following are all added to the search list:\n        \"OK\", \"Button\", \"OKButton\"\n    \n        But if there is a ListView (which do not have visible 'text')\n        then it will just add \"ListView\".\n        \"\"\"\n        name_control_map = build_unique_dict(controls)\n    \n    \n        #print \">>>>>>>\", repr(name_control_map).decode(\"ascii\", \"ignore\")\n    #    # collect all the possible names for all controls\n    #    # and build a list of them\n    #    for ctrl in controls:\n    #        ctrl_names = get_control_names(ctrl, controls)\n    #\n    #        # for each of the names\n    #        for name in ctrl_names:\n    #            name_control_map[name] = ctrl\n    \n        search_text = six.text_type(search_text)\n    \n        best_ratio, best_texts = name_control_map.find_best_matches(search_text)\n    \n        best_ratio_ci, best_texts_ci = \\\n            name_control_map.find_best_matches(search_text, ignore_case = True)\n    \n        best_ratio_clean, best_texts_clean = \\\n            name_control_map.find_best_matches(search_text, clean = True)\n    \n        best_ratio_clean_ci, best_texts_clean_ci = \\\n            name_control_map.find_best_matches(\n                search_text, clean = True, ignore_case = True)\n    \n    \n        if best_ratio_ci > best_ratio:\n            best_ratio = best_ratio_ci\n            best_texts = best_texts_ci\n    \n        if best_ratio_clean > best_ratio:\n            best_ratio = best_ratio_clean\n            best_texts = best_texts_clean\n    \n        if best_ratio_clean_ci > best_ratio:\n            best_ratio = best_ratio_clean_ci\n            best_texts = best_texts_clean_ci\n    \n        if best_ratio < find_best_control_match_cutoff:\n>           raise MatchError(items = name_control_map.keys(), tofind = search_text)\nE           pywinauto.findbestmatch.MatchError: Could not find '打开文件' in 'dict_keys(['Shell_TrayWnd', '设置Shell_TrayWnd', 'Shell_SecondaryTrayWnd', '计算器Shell_SecondaryTrayWnd', 'Qt5QWindowIcon', 'LuxCreoQt5QWindowIcon', 'LuxCreo', 'Windows.UI.Core.CoreWindow', 'TaskManagerWindow', '任务管理器TaskManagerWindow', '任务管理器', 'Alternate Owner', 'D:\\\\install\\\\html (14) - Internet ExplorerIEFrame', 'IEFrame', 'D:\\\\install\\\\html (14) - Internet Explorer', 'Alternate Owner0', 'Alternate Owner1', 'Alternate Owner2', '计算器', 'ApplicationFrameWindow', '计算器ApplicationFrameWindow', 'popupshadow', 'DuiShadowWnd', 'DuiShadowWnd0', 'DuiShadowWnd1', 'DuiShadowWnd2', 'DuiShadowWnd3', 'ApplicationFrameWindow0', 'ApplicationFrameWindow1', 'ApplicationFrameWindow2', 'Windows.UI.Core.CoreWindow0', 'Windows.UI.Core.CoreWindow1', 'Windows.UI.Core.CoreWindow2', '设置', 'ApplicationFrameWindow3', '设置ApplicationFrameWindow', 'ApplicationFrameWindow4', 'Microsoft Text Input ApplicationApplicationFrameWindow', 'Windows.UI.Core.CoreWindow3', 'Microsoft Text Input Application', 'Microsoft Text Input ApplicationWindows.UI.Core.CoreWindow', 'EdgeUiInputTopWndClass', '设置EdgeUiInputTopWndClass', 'EdgeUiInputTopWndClass0', 'EdgeUiInputTopWndClass1', 'EdgeUiInputTopWndClass2', 'DummyDWMListenerWindow', 'DummyDWMListenerWindow0', 'DummyDWMListenerWindow1', 'DummyDWMListenerWindow2', 'DummyDWMListenerWindow3', 'Internet Explorer_Hidden', 'Internet Explorer_Hidden0', 'Internet Explorer_Hidden1', 'Internet Explorer_Hidden2', 'CabinetWClass', 'install', 'installCabinetWClass', 'LuxFlow测试用例以及自动化项目计划.xlsx - WPS OfficeXLMAIN', 'LuxFlow测试用例以及自动化项目计划.xlsx - WPS Office', 'XLMAIN', 'FoxmailTApplication', 'TApplication', 'Foxmail', 'Chrome_WidgetWin_1', 'Allure Report - 个人 - Microsoft\\u200b Edge', 'Allure Report - 个人 - Microsoft\\u200b EdgeChrome_WidgetWin_1', 'LuxFlow_front – test_main.py', 'LuxFlow_front – test_main.pySunAwtFrame', 'SunAwtFrame', 'Chrome_WidgetWin_10', 'Chrome_WidgetWin_11', 'Chrome_WidgetWin_12', '在线翻译_有道 - Google Chrome', '在线翻译_有道 - Google ChromeChrome_WidgetWin_1', 'Order System::Bug - 禅道 - Google Chrome', 'Chrome_WidgetWin_13', 'Order System::Bug - 禅道 - Google ChromeChrome_WidgetWin_1', 'Chrome_WidgetWin_14', '清锋时代 - 3D打印规模化服务商 - Google ChromeChrome_WidgetWin_1', '清锋时代 - 3D打印规模化服务商 - Google Chrome', 'Program Manager', 'Progman', 'Program ManagerProgman'])'\n\nd:\\program files(x86)\\python3.7\\lib\\site-packages\\pywinauto\\findbestmatch.py:536: MatchError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <testcase.testcase.test_main.TestMain object at 0x000002270D6B7D30>, start_flow = <flow_page.main_page.MainPage object at 0x000002270D6B7D68>\nprocess_date = {'copy_num': 3, 'layout_mode': 2, 'model': '\"孔洞花瓶.stl\" \"谢牙龈.stl\"', 'opentext': '本地打开', ...}\n\n    @allure.story(\"全流程测试\")\n    @pytest.mark.parametrize(\"process_date\", [process_date], ids=[\"全流程测试\"])\n    def test_openpart(self, start_flow, process_date):\n        with allure.step(\"打开零件\"):\n            start_flow.jump_button(oper=\"打开\")\n            #\n>           openfile = start_flow.openfile(process_date[\"path\"], process_date[\"model\"])\n\ntestcase\\testcase\\test_main.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nflow_page\\main_page.py:191: in openfile\n    LogRoot.error(\"报错处理\", e)\nd:\\program files(x86)\\python3.7\\lib\\logging\\__init__.py:1412: in error\n    self._log(ERROR, msg, args, **kwargs)\nd:\\program files(x86)\\python3.7\\lib\\logging\\__init__.py:1519: in _log\n    self.handle(record)\nd:\\program files(x86)\\python3.7\\lib\\logging\\__init__.py:1529: in handle\n    self.callHandlers(record)\nd:\\program files(x86)\\python3.7\\lib\\logging\\__init__.py:1591: in callHandlers\n    hdlr.handle(record)\nd:\\program files(x86)\\python3.7\\lib\\logging\\__init__.py:905: in handle\n    self.emit(record)\nd:\\program files(x86)\\python3.7\\lib\\site-packages\\_pytest\\logging.py:331: in emit\n    super().emit(record)\nd:\\program files(x86)\\python3.7\\lib\\logging\\__init__.py:1040: in emit\n    self.handleError(record)\nd:\\program files(x86)\\python3.7\\lib\\logging\\__init__.py:1034: in emit\n    msg = self.format(record)\nd:\\program files(x86)\\python3.7\\lib\\logging\\__init__.py:880: in format\n    return fmt.format(record)\nd:\\program files(x86)\\python3.7\\lib\\site-packages\\_pytest\\logging.py:92: in format\n    return super().format(record)\nd:\\program files(x86)\\python3.7\\lib\\logging\\__init__.py:619: in format\n    record.message = record.getMessage()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <LogRecord: log, 40, E:\\LuxFlow_front\\flow_page\\main_page.py, 191, \"报错处理\">\n\n    def getMessage(self):\n        \"\"\"\n        Return the message for this LogRecord.\n    \n        Return the message for this LogRecord after merging any user-supplied\n        arguments with the message.\n        \"\"\"\n        msg = str(self.msg)\n        if self.args:\n>           msg = msg % self.args\nE           TypeError: not all arguments converted during string formatting\n\nd:\\program files(x86)\\python3.7\\lib\\logging\\__init__.py:380: TypeError"}, "steps": [{"name": "打开零件", "status": "broken", "statusDetails": {"message": "TypeError: not all arguments converted during string formatting\n", "trace": "  File \"E:\\LuxFlow_front\\testcase\\testcase\\test_main.py\", line 27, in test_openpart\n    openfile = start_flow.openfile(process_date[\"path\"], process_date[\"model\"])\n  File \"E:\\LuxFlow_front\\flow_page\\main_page.py\", line 191, in openfile\n    LogRoot.error(\"报错处理\", e)\n  File \"d:\\program files(x86)\\python3.7\\lib\\logging\\__init__.py\", line 1412, in error\n    self._log(ERROR, msg, args, **kwargs)\n  File \"d:\\program files(x86)\\python3.7\\lib\\logging\\__init__.py\", line 1519, in _log\n    self.handle(record)\n  File \"d:\\program files(x86)\\python3.7\\lib\\logging\\__init__.py\", line 1529, in handle\n    self.callHandlers(record)\n  File \"d:\\program files(x86)\\python3.7\\lib\\logging\\__init__.py\", line 1591, in callHandlers\n    hdlr.handle(record)\n  File \"d:\\program files(x86)\\python3.7\\lib\\logging\\__init__.py\", line 905, in handle\n    self.emit(record)\n  File \"d:\\program files(x86)\\python3.7\\lib\\site-packages\\_pytest\\logging.py\", line 331, in emit\n    super().emit(record)\n  File \"d:\\program files(x86)\\python3.7\\lib\\logging\\__init__.py\", line 1040, in emit\n    self.handleError(record)\n  File \"d:\\program files(x86)\\python3.7\\lib\\logging\\__init__.py\", line 1034, in emit\n    msg = self.format(record)\n  File \"d:\\program files(x86)\\python3.7\\lib\\logging\\__init__.py\", line 880, in format\n    return fmt.format(record)\n  File \"d:\\program files(x86)\\python3.7\\lib\\site-packages\\_pytest\\logging.py\", line 92, in format\n    return super().format(record)\n  File \"d:\\program files(x86)\\python3.7\\lib\\logging\\__init__.py\", line 619, in format\n    record.message = record.getMessage()\n  File \"d:\\program files(x86)\\python3.7\\lib\\logging\\__init__.py\", line 380, in getMessage\n    msg = msg % self.args\n"}, "start": 1644545094204, "stop": 1644545106379}], "attachments": [{"name": "log", "source": "5738804c-5302-4ee3-b988-93ba522d8966-attachment.txt", "type": "text/plain"}], "parameters": [{"name": "process_date", "value": "{'path': 'E:\\\\model\\\\model', 'model': '\"孔洞花瓶.stl\" \"谢牙龈.stl\"', 'opentext': '本地打开', 'support_parameter': {'抬升高度': 10, '支撑点直径': 1.5, '支撑头长度': 2.5, '支撑柱直径': 1.5, '支撑点间距': 4.5, '临界角': 75, '是否加固': True, '起始高度': 1.5, '角度': 50, '支撑加底座': True, '底座高度': 1.5}, 'copy_num': 3, 'spacing': 5, 'layout_mode': 2, 'thickness_type': '自定义'}"}], "start": 1644545094203, "stop": 1644545106404, "uuid": "8a9bfd9d-5230-4b22-b559-5682bc4469af", "historyId": "c766fd61ec11046c1c893884027439f7", "testCaseId": "e11bed7529b8dd4ec58c808e5a240e2f", "fullName": "testcase.testcase.test_main.TestMain#test_openpart", "labels": [{"name": "story", "value": "全流程测试"}, {"name": "parentSuite", "value": "testcase.testcase"}, {"name": "suite", "value": "test_main"}, {"name": "subSuite", "value": "TestMain"}, {"name": "host", "value": "DESKTOP-O8SQ26U"}, {"name": "thread", "value": "20736-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "testcase.testcase.test_main"}]}